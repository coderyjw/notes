- 深入浏览器运行原理
  - 浏览器输入 url 到页面展示
    - DNS 域名解析成对应 ip 地址
    - 三次握手建立 TCP 连接
    - 发起请求
    - 服务器响应处理请求
    - 服务器返回资源
    - 浏览器解析
  - 网页的解析过程
    - 下载 html
    - 遇到 link 下载 css 文件
    - 遇到 script 下载 js 文件
  - 浏览器渲染流程
    - HTML 解析
      - 默认情况下服务器返回 index.html
      - 解析 HTML 生成 DOM Tree
    - CSS 解析
      - 生成 CSS Rules 不阻塞 html 解析（不影响 DOM Tree 生成 但是有可能会影响 Render Tree 生成）
    - 生成 Render Tree
      - DOM Tree 和 CSS Rules Attach(附加在一起)
      - Render Tree 和 DOM Tree 不是一一对应的关系(display:none 为例子,不会出现在 render tree 中)
    - 布局 layout 和绘制 paint
      - 布局阶段确定渲染树的尺寸 位置信息
      - 绘制阶段，将布局阶段计算的每个 frame 转为屏幕上实际的像素点（文本、颜色、边框、阴影、替换元素）
    - 合成 composite
      - 绘制的过程，可以将布局后的元素绘制到多个合成图层中
      - 默认情况下，标准流中的内容都是被绘制在同一个图层中的
      - 而一些特殊的属性，会创建新的合成层，并且新的图层可以利用 GPU 来加速绘制（因为每个合成层都是单独渲染）
  - 回流和重绘解析
    - 回流(重排)reflow
      - 第一次确定节点的大小和位置，称之为布局 layout
      - 之后对节点的大小、位置修改重新计算称之为回流（重排）
      - 引起回流的情况：dom 结构改变 改变了布局 修改窗口尺寸 getComputedStyle
    - 重绘
      - 第一次渲染内容称之为绘制
      - 之后称为重绘
      - 修改样式
    - 尽量避免回流
      - 修改样式时尽量一次性修改
      - 尽量避免频繁操作 DOM
      - 尽量避免通过 getComputedStyle 获取尺寸、位置
      - 对某些元素使用 position 的 absolution 和 fixed
  - 合成和性能优化
    - 浏览器的优化手段
  - defer 和 async 属性
    - js 脚本会阻塞 dom 解析
    - defer:
      - 不阻塞 DOM Tree 构建过程
      - 如果脚本提前下载好了，会等待 DOM Tree 完成，在 DOMContentLoaded 事件之前执行 defer 中的代码
      - 顺序执行
      - 放在 head 里
      - 只对外部脚本生效
    - async:
      - 不阻塞 DOM Tree 构建
      - 不管页面，下载好后立马执行（危险 下载完有可能 DOM 构建好也有可能没构建好）
      - 顺序不一定 不能保证在 DOMContentLoaded 之前或之后执行
- 深入 Javascript 运行原理
  - 深入 V8 引擎原理
    - Parse（解析）: js 源代码解析称 AST 抽象语法树
    - Ignition（解释器）: AST 转换成 ByteCode 字节码
    - TurboFan(编译器): 字节码编译成 CPU 可以直接执行的机码，（对频繁的操作的热点函数做机器码优化，提高性能）
  - JS 执行上下文
    - js 引擎在执行代码前，会在堆内存中创建一个全局对象 Golbal Object（包含 Date Array String Number SetTimout）
    - js 引擎内部有个执行上下文栈 ECS
    - 全局代码块会构建一个全局执行上下文 GEC，GEC 被放在 ECS 中执行
      - 在代码执行前，parser 转成 AST 的过程，会讲全局定义的变量、函数等加入到 GO，但不会执行
      - 在代码执行中，对变量赋值，并执行函数
    - 每个执行上下文会关联到一个 VO 对象，变量和函数声明会被添加到这个对象上（全局上下文的 VO 就是 GO，函数的上下文叫AO）
  - 全局代码执行过程
  - 函数代码执行过程
  - 作用域和作用域链
    - 作用域查找和定义的地方有关系和调用的地方没关系
