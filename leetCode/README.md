# 1.栈

- 栈是一个先进后出的数据结构
- js 中没有队列，但可以用 Array 实现队列的所有功能
- 队列常用操作: push、pop、stack[stack.length - 1]
-

# 2.队列

- 队列是一个先进先出的数据结构
- js 中没有队列，但可以用 Array 实现队列的所有功能
- 队列常用操作: push、shift、queue[0]

# 3.链表

- 链表里的元素存储不是连续的，之间通过 next 链接。
- js 中没有链表，但可以用 Object 模拟链表
- 链表常用操作：修改 next、遍历链表
- js 中的圆形链也是一个链表
- 使用链表指针可以获取 json 的节点值

# 4.字典

- 与集合类似，字典也是一种存储唯一值的数据结构，但它是以键值对的形式来存储。
- ES6 中有字典，名为 Map。
- 字典的常用操作：键值对的增删改查

# 5.集合

- 集合是一种 无序且唯一的数据结构
- ES6 中有集合，名为 Set。
- 集合的常用操作：去重、判断某元素是否在集合中、求交集

# 6.树

- 一种分层数据的抽象模型
- js 中没有树，但是我们可以用 Object 和 Array 来构建树
- 树的常用操作：深/广度优先遍历、先中后序遍历......

## 6.1 二叉树

- 树中每个节点最多只能有两个子节点
- 在 js 中通常用 Object 来模拟二叉树

# 7.图

- 图是网络结构的抽象模型，是一组由边连接的节点。
- 图可以表示任何二元关系。
- js 中没有图，但是可以用 Object 和 Array 构建图
- 图的表示法有：邻接矩阵、邻接表、关联矩阵......

# 8.堆

- 堆是一种特殊的完全二叉树
- 所有的节点都大于等于或小于等于他的子节点
- js 中通常使用数组表示堆
  - 左侧子节点的位置 2 \* index + 1
  - 右侧子节点的位置 2 \* index + 2
  - 父节点的位置（index - 1）/ 2
- 堆的应用
  - 堆能快速高效的找出最大值和最小值 O（1）
  - 找出第 k 个最大（小）元素
    1. 构建一个最小堆，并将元素依次插入堆中
    2. 当堆的容量超过 K，就删除堆顶
    3. 插入结束后，堆顶就是第 K 哥最大元素

# 9.排序和搜索

- 排序： 把某个乱序的数组变成升序或者降序的数组
- 搜索： 找出数组中的某个元素的下标
- JS 中的排序: 数组的 sort 方法和 indexOf 方法
- 排序算法包括：冒泡排序、归并排序、选择排序、快速排序、插入排序
- 搜索：顺序搜索、二分搜索

## 9.1 冒泡排序

1. 比较所有相邻元素，如果第一个比第二个大，则交换它们。
2. 一轮下来，可以保证最后一个数是最大的。
3. 执行 n-1 轮，就可以完成排序。

## 9.2 选择排序

1. 找到数组中的最小值，选中它并将其放置在第一位。
2. 接着找到第二小的值，选中它并将其放置在第二位。
3. 以此类推，执行 n-1 轮

## 9.3 插入排序

1. 从第二个数开始往前比。
2. 比它大就往后排。
3. 以此类推进行到最后一个数。

## 9.4 归并排序

1. 分：把数组劈成两半，再递归地对子数组进行“分”操作，直到分成一个个单独的数。
2. 合：把两个数合并为有序数组，再对有序数组进行合并，直到全部子数组合并为一个完整数组

## 9.5 快速排序

- 分区：从数组中任意选择一个"基准"，所有比基准小的元素放在基准前面，比基准大的元素放在基准的后面。
- 递归：递归地对基准前后的子数组进行分区

# 10. 分而治之

- 分而治之是算法设计中的一种方法
- 他将一个问题分成多个和原问题相似的小问题，递归解决小问题，再将结合合并已解决原来的问题
- 如：归并排序 快速排序 二分搜索 翻转二叉树

# 11. 动态规划

- 动态规划是算法设计中的一种。
- 它将一个问题分解为互相重叠的子问题，通过反复求解子问题，来解决原来的问题。

# 12. 贪心算法

- 贪心算法是算法设计里的一种
- 期盼通过每个阶段的局部最优选择，从而达到全局的最优
- 结果并不一定是最优解（零钱兑换，天龙八部-珍珑棋局）

# 13. 回溯算法

- 回溯算法是算法设计中的一种
- 回溯算法是一种渐进式寻找并构建问题解决方式的策略
- 回溯算法会先从一个可能的动作开始解决问题，如果不行，就回溯并选择另一个动作，直到将问题解决。
- 全排列、子集
