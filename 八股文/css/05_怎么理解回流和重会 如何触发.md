# 1. 是什么？

在 html 中， 每个元素可以看成是一个盒子，在浏览器解析的过程中，会涉及到回流和重绘

- 回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置
- 重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制

具体浏览器解析渲染机制：

1. 浏览器解析 DOM 生成 DOM Tree
2. 浏览器解析 CSS 生成 CSS Tree
3. 浏览器将 DOM 树和 CSS 树结合生成渲染树 Render Tree
4. Layout 回流，根据生成的渲染数，进行回流，得到节点的几何信息（位置、大小）
5. Painting 重绘，根据渲染树以及回流得到的几何信息，得到节点的绝对像素
6. Display，将像素发送给 GPU,展示在页面上

当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，
浏览器需要重新计算元素的几何属性，然后再将计算的结果绘制出来

当我们对 DOM 的修改导致了样式的变化（color 或 background-color），
却并未影响其几何属性时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式，这里就仅仅触发了回流

# 2. 回流触发时机

回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流，如下面情况：

- 添加或删除可见的 DOM 元素
- 元素的位置发生变化
- 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代
- 页面一开始渲染的时候（这避免不了）
- 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）

还有一些容易被忽略的操作：获取一些特定属性的值
offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight
这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流
除此还包括 getComputedStyle 方法，原理是一样的

# 3. 重绘触发时机

- 触发回流一定会触发重绘
- 可以把页面理解为一个黑板，黑板上有一朵画好的小花。现在我们要把这朵从左边移到了右边，那我们要先确定好右边的具体位置，画好形状（回流），再画上它原有的颜色（重绘）
- 除此之外还有一些其他引起重绘行为：
- 颜色的修改
- 文本方向的修改
- 阴影的修改
