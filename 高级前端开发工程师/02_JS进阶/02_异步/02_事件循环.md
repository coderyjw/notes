js使用事件循环来实现单线程非阻塞

- js为什么要设计成单线程？
  因为最初定位只是一种脚本语言，用途是于浏览器交互。

我们通常把宿主发起的任务成为宏任务，把js引擎发起的任务称为微任务
- 宏任务
  - setInterval()
  - setTimeout()
- 微任务
  - Promise().then(function(){})
  - new MutationObserver()

先执行同步代码 检查执行微任务队列 再检查执行宏任务队列


- 为什么要设计微任务？
微任务解决了宏任务执行时机不可控的问题

- 总结
js是一种单线程语言，可以理解为同一个时间只能执行一段代码片段。
为什么是单线程，因为js最初设计的时候是把他设计成一种于浏览器交互的脚本语言，那么可以试想如果我
有两个线程分别修改了dom上的文字，那这个dom的文字到底显示那个比较好，而且单线程效率会更高一点。
单线程就会有阻塞的问题，比如在js中请求一个异步的IO请求，在等待结果返回的时候后面的代码就无法执行
浏览器就会看起来卡住了。而js就是靠事件循环机制来实现异步任务的。
事件循环机制
1. 一开始整个脚本作为宏任务执行
2. 执行过程中同步代码直接执行，微任务进入微任务队列，宏任务进入宏任务队列
3. 当同步代码执行完后，读取微任务列表，有则依次执行，直到全部执行完
4. 执行浏览器 UI 线程的渲染工作
5. 检查是否有 Web Worker 任务，有则执行
6. 最后执行完本轮宏任务，回到第二步

