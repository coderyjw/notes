# 1. TCP/IP 协议群
## 1.1 是什么？
`TCP/IP`，**传输控制协议/网际协议**，是指能够在多个不同网络间实现信息传输的**协议簇**

- `TCP（传输控制协议）`
一种面向连接的、可靠的、基于字节流的传输层通信协议

- `IP（网际协议）`
用于封包交换数据网络的协议

`TCP/IP`协议不仅仅指的是`TCP` 和`IP`两个协议，而是指一个由`FTP`、`SMTP`、`TCP`、`UDP`、`IP`等协议构成的协议簇，

只是因为在`TCP/IP`协议中`TCP`协议和`IP`协议最具代表性，所以通称为`TCP/IP`协议族（英语：`TCP/IP Protocol Suite`，或`TCP/IP Protocols`）
<!-- more -->

## 1.2 划分
TCP/IP协议族按层次分别了五层体系或者四层体系

五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层

五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构，包括应用层、传输层、网络层（网际互联层）、网络接口层

如下图所示：

![5bb93610-b647-11eb-85f6-6fac77c0c9b3.png](https://yejiwei.com/static/img/74350f50b2f2bcf915001cf64219545e.5bb93610-b647-11eb-85f6-6fac77c0c9b3.png)
### 五层体系
- 应用层 Application 

    **提供应用间的通信能力**

    `TCP/IP` 模型将 `OSI` 七层模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务。

    如：`FTP`、`Telnet`、`DNS`、`SMTP` 等
    
![Snipaste_2022-11-08_23-49-57.png](https://yejiwei.com/static/img/f26f2ca3a90db0b07d5ef66ffac037ef.Snipaste_2022-11-08_23-49-57.png)

- 传输层 Transport. 

    **提供主机到主机(host-to-host)的通信功能**

    传输层定义了两个主要协议：`传输控制协议（TCP）`和`用户数据报协议（UDP）`

    其中面向连接的 `TCP` 协议保证了数据的传输可靠性，面向无连接的 `UDP` 协议能够实现数据包简单、快速地传输

![Snipaste_2022-11-08_23-49-16.png](https://yejiwei.com/static/img/2467f5f1803ef0b4be68dbdc09cbef60.Snipaste_2022-11-08_23-49-16.png)
- 网络层 Internet 

    **提供地址到地址的通信能力**

    像物流公司一样 将封包从一个 ip 地址送到另一个 ip 地址， 中间会有很多的网络设备(路由器)

![image.png](https://yejiwei.com/static/img/103155318bd93bf5e7465a2f99a8ce60.image.png)
- 链接层 Link 
    **提供设备到设备之间的通信能力**
    
![Snipaste_2022-11-08_23-52-22.png](https://yejiwei.com/static/img/61086d90735b18adb80a86d18520204a.Snipaste_2022-11-08_23-52-22.png)
- 物理层 Pysical 
   ** 提供光电信号在各种物理媒介上的通信能力**

### 四层体系

| 层次名称 | 单位 | 功能 | 协 议 |
| --- | --- | --- |  --- |
|网络接口层| 帧 | 负责实际数据的传输，对应OSI参考模型的下两层 | HDLC（高级链路控制协议）PPP（点对点协议） SLIP（串行线路接口协议） |
|网络层| 数据报| 负责网络间的寻址数据传输，对应OSI参考模型的第三层|IP（网际协议） ICMP（网际控制消息协议）ARP（地址解析协议） RARP（反向地址解析协议）|
|传输层|报文段|负责提供可靠的传输服务，对应OSI参考模型的第四层|TCP（控制传输协议） UDP（用户数据报协议）|
|应用层||负责实现一切与应用程序相关的功能，对应OSI参考模型的上三层|FTP（文件传输协议） HTTP（超文本传输协议） DNS（域名服务器协议）SMTP（简单邮件传输协议）NFS（网络文件系统协议）|

## 1.3 OSI 参考模型与 TCP/IP 参考模型区别
相同点：
- `OSI` 参考模型与 `TCP/IP` 参考模型都采用了层次结构
- 都能够提供面向连接和无连接两种通信服务机制

不同点：
- `OSI` 采用的七层模型； `TCP/IP` 是四层或五层结构
- `TCP/IP` 参考模型没有对网络接口层进行细分，只是一些概念性的描述； `OSI` 参考模型对服务和协议做了明确的区分
- `OSI` 参考模型虽然网络划分为七层，但实现起来较困难。`TCP/IP` 参考模型作为一种简化的分层结构是可以的
- `TCP/IP`协议去掉表示层和会话层的原因在于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 `OSI` 设想中的应用程序维度的分层是无法实现的



# 2. TCP的三次握手和四次挥手
## 2.1 三次握手
三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包

主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备

过程如下：
- 第一次握手：客户端给服务端发一个 `SYN` 报文，请求服务端同步，此时客户端处于 `SYN_SEND`（同步发送的） 状态
- 第二次握手：服务器收到客户端的 `SYN` 报文（请求服务端同步的消息）之后，自己会进入一个 `SYN-RECEIVED`（同步监听的）状态，并且会以自己的 `SYN-ACK` 报文作为应答（告诉客户端已经确认收到了的请求）
- 第三次握手：客户端收到 `SYN` 报文之后，会进入 `ESTABLISHED`（已连接） 状态，并且会再发送一个 `ACK` 报文 给服务端。服务器收到 ACK 报文之后，才会确认数据已经连接，并且进入 `ESTABLISHED`（已连接） 状态。

**关键字说明：**
- SYN：Synchronize Sequence Numbers，同步序列编号）  
- ACK：Acknowledge Character，确认字符

![Snipaste_2022-11-09_00-42-12.png](https://yejiwei.com/static/img/986fd24f63daaf02d54d56d8faaf71be.Snipaste_2022-11-09_00-42-12.png)

上述每一次握手的作用如下：
- 第一次握手：客户端发送网络包，服务端收到了 这样服务端就能得出结论：**客户端的发送能力、服务端的接收能力是正常的。**
- 第二次握手：服务端发包，客户端收到了 这样客户端就能得出结论：**服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。**
- 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：**客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常**

通过三次握手，就能确定双方的接收和发送能力是正常的。之后就可以正常通信了

- **为什么不是两次握手?**

如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 无法确定自己发的包对方能收到

并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源

- **如何解决数据顺序?**

    TCP/IP协议的处理方法是 用（`SEQ`，`ACK`）这一对元组描述消息的绝对顺序
- **SEQ(Sequence 序列)**：这个消息发送之前一共发送了多少字节。
- **ACK(Acknowledge)**：这个消息发送前一共收到多少字节。


![Snipaste_2022-11-09_00-58-27.png](https://yejiwei.com/static/img/1dd66d4bd39b81c9e7b5f9782befedb7.Snipaste_2022-11-09_00-58-27.png)

## 2.2 四次挥手

tcp终止一个连接，需要经过四次挥手

过程如下：
- 第一次挥手：客户端发送一个 `FIN` 报文。此时客户端进入 `FIN_WAIT1` 状态，停止发送数据，等待服务端的确认。
- 第二次挥手：服务端收到 `FIN` 之后，会发送 `ACK` 报文，表明已经收到客户端的报文了，此时服务端进入 `CLOSE_WAIT` 状态。
- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 `FIN` 报文。此时服务端进入 `LAST_ACK` 的状态
- 第四次挥手：客户端收到 `FIN` 之后，一样发送一个 `ACK` 报文作为应答，此时客户端进入 `TIME_WAIT` 状态。需要过一阵子以确保服务端收到自己的 `ACK` 报文之后才会进入 `CLOSED` 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 `CLOSED` 状态。


![Snipaste_2022-11-09_01-09-45.png](https://yejiwei.com/static/img/7c01563f8c6365e76672a6c4b014d817.Snipaste_2022-11-09_01-09-45.png)

**四次挥手原因**

服务端在收到客户端断开连接Fin报文后，并不会立即关闭连接，而是先发送一个ACK包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送FIN报文断开连接，因此需要四次挥手。

# 3. 总结与思考
- 最简化原则
    
    没有足够的事情要做，就不必分层 （OSI的七层 -> TCP/IP的 `四/五` 层）
- 为什么需要三次握手？
  
  TCP协议是一个 `面向连接的`、`可靠的`、`基于字节流`的传输层协议。
  
  **重点就是要可靠。**
- 为什么不是两次握手?
    
    1. 如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，**但接收端只能确定对方发的包自己能收到 无法确定自己发的包对方能收到**。

    2. 并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源。
    
- 为什么不是四次 五次握手?

    **因为没必要，三次握手就可以符合实际情况，为了节省资源。**
- 网络中的顺序问题，TCP协议给了完美的解法(seq、ack)，这个方法是可以迁移的。（学习算法的价值）
  

